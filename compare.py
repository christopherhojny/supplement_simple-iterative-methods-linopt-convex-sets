#!/usr/bin/env python3
from oracles import *
from problems import *
from auxiliary import *
from packing_algorithm import *
from cutloop import *

import sys
import os
import math
import numpy
import matplotlib.pyplot as plt
import time

####################################################################################################
#
# EVALUATION OF EXPERIMENTS
#
####################################################################################################


def compare_primal_dual_LP(dual_bounds_LP, gamma_vals, cuts, cut_rounds, all_f, all_a, r,
                           problemtype, solver, instancefile, initconss, suffix=""):
    '''
    generate plots to compare the primal/dual progress of our method with the dual values
    of the classical cutting plane loop
    dual_bounds_LP - list containing dual bound of LP loop for each iteration
    gamma_vals     - list of primal bounds of our routine for each iteration
    cuts           - list of cuts generated by our routine
    cut_rounds     - list of indices indicating in which round a cut has been generated
    all_f          - list of target vectors for each iteration
    all_a          - list of dual points for each iteration
    r              - radius of interior ball
    problemtype    - string specifying the problem type
    solver         - solver to compute dual bounds of our routine
    instancefile   - path to file encoding instance
    initconss      - {0,1,2} to encode whether no/box/standard constraints shall be
                     used to compute dual bounds for our method
    suffix         - (optional) information on instance given in plot title
    '''

    # create problem instance to compute dual bounds for our method
    problem = PROBLEM(instancefile, problemtype, solver, initconss)
    dual_bounds = []

    # compute dual bounds after a cut has been added
    for cut in cuts:
        problem.add_cut(cut)
        dual_bounds.append(problem.optimize())

    # generate the dual bounds for each iteration from the cut rounds
    plot_dual_bounds = [dual_bounds[0]]
    cut_cnt = 0
    for i in range(1, len(gamma_vals)):
        if cut_cnt < len(cut_rounds) and cut_rounds[cut_cnt] == i:
            cut_cnt += 1
            plot_dual_bounds.append(dual_bounds[cut_cnt])
        else:
            plot_dual_bounds.append(plot_dual_bounds[-1])

    # compute differences between f and a
    f_diff_a = []
    for i in range(len(all_f)):
        f_diff_a.append((numpy.sqrt(sum((all_f[i][j] - all_a[i][j])**2
                                        for j in range(len(all_f[i]))
                                        if all_f[i][j] - all_a[i][j] > 0 ))))

    # compute estimation on difference of f and a
    est_f_diff_a = [numpy.nan] + [1/(r * numpy.sqrt(t)) for t in range(1,len(plot_dual_bounds))]

    x = range(max(len(plot_dual_bounds), len(dual_bounds_LP)))

    # create plot with log-scale
    fig, ax1 = plt.subplots()

    lns = ax1.plot(x[:len(plot_dual_bounds)], plot_dual_bounds, label='dual from A_t')
    lns += ax1.plot(x[:len(gamma_vals)], gamma_vals, label='gamma_t')
    lns += ax1.plot(x[:len(dual_bounds_LP)], dual_bounds_LP, label='dual from LP', color='red')
    try:
        logdist = [ -math.log10(item) for item in f_diff_a ]
        ax2 = ax1.twinx()
        ax1.set_ylabel('objective value')
        ax2.set_ylabel('-log_10(dist)')
        ax1.set_xlabel('iterations')
        lns += ax2.plot(x[:len(logdist)], logdist, label='-log_10(dist^2)', color='green')
    except Exception as e:
        print(e)
        pass

    labs = [l.get_label() for l in lns]
    ax1.legend(lns, labs)

    plt.xlabel('iterations')
    plt.xscale('log')

    title = instancefile.split('/')[-1]+suffix
    plt.title(title)

    # plt.show()
    plotfilename = title.replace(" ", "_")
    plotfilename = "log_" + plotfilename
    if not os.path.exists("plots"):
        os.makedirs("plots")
    plt.savefig("plots/{}.png".format(plotfilename))

    # create plot with linear-scale
    fig, ax1 = plt.subplots()

    lns = ax1.plot(x[:len(plot_dual_bounds)], plot_dual_bounds, label='dual from A_t')
    lns += ax1.plot(x[:len(gamma_vals)], gamma_vals, label='gamma_t')
    lns += ax1.plot(x[:len(dual_bounds_LP)], dual_bounds_LP, label='dual from LP', color='red')

    labs = [l.get_label() for l in lns]
    ax1.legend(lns, labs)

    plt.xlabel('iterations')

    title = instancefile.split('/')[-1]+suffix
    plt.title(title)

    # plt.show()
    plotfilename = title.replace(" ", "_")
    plt.savefig("plots/{}.png".format(plotfilename))

    # create logs
    if not os.path.exists("logs"):
        os.makedirs("logs")
    f = open("logs/%s.txt" % plotfilename, 'w')
    f.write("dualDHHW\n")
    for val in plot_dual_bounds:
        f.write("%f " % val)
    f.write("\nprimalDHHW\n")
    for val in gamma_vals:
        f.write("%f " % val)
    f.write("\ndualLP\n")
    for val in dual_bounds_LP:
        f.write("%f " % val)
    f.close()



####################################################################################################
#
# MAIN METHOD
#
####################################################################################################



if __name__=='__main__':

    # default values of general parameters
    instancefile = ""
    problemtype = "matching"
    precision = 0.0001
    maxiter = 1000

    try:
        import pyscipopt
        solver = "scip"
    except ImportError:
        try:
            import gurobipy
            solver = "gurobi"
        except ImportError:
            sys.exit("ERROR cannot locate SCIP or Gurobi Python interface")

    silent = True
    corr_freq = -1
    initconss = 1
    lbopt = -1

    allowedtypes = ["matching", "weightmatching", "stableset", "weightstableset"]

    # read instance parameters
    for i in range(1, len(sys.argv)):
        arg = sys.argv[i]
        if arg.startswith("--file"):
            instancefile = arg.split('=')[1]
        elif arg.startswith("--type"):
            problemtype = arg.split('=')[1]

            if not problemtype in allowedtypes:
                msg = "ERROR unkown type of problem."
                msg += "Allowed types are {}, but '{}' was given".format(allowedtypes, problemtype)
                sys.exit(msg)

        elif arg.startswith("--precision"):
            precision = float(arg.split('=')[1])
        elif arg.startswith("--maxiter"):
            maxiter = int(arg.split('=')[1])
        elif arg.startswith("--solver"):
            solver = arg.split('=')[1]
        elif arg.startswith("--nosilent"):
            silent = False
        elif arg.startswith("--corrfreq"):
            corr_freq = int(arg.split('=')[1])
        elif arg.startswith("--initconss"):
            initconss = int(arg.split('=')[1])
        elif arg.startswith("--lbopt"):
            lbopt = float(arg.split('=')[1])
        else:
            sys.exit("ERROR unkown argument %s." % arg)

    # generate instance and solve it
    OPT = -1
    oracle = ORACLE(instancefile, problemtype, solver)

    # initialize parameters for our algorithm
    obj = oracle.get_obj()
    norm_obj = sum(val * val for val in obj)
    norm_obj = numpy.sqrt(norm_obj)
    inner_radius = oracle.get_inner_radius()
    gamma = norm_obj * inner_radius
    if lbopt > gamma:
        gamma = lbopt

    # list of cuts used for the fully corrective step
    initial_conss = []
    if initconss >= 1:
        initial_conss.extend(get_ub_conss(len(obj)))
    if initconss == 2:
        initial_conss.extend(oracle.get_standard_cuts())

    # get results for our algorithm
    verif_model = PROBLEM(instancefile, problemtype, solver, initconss)
    OPT, separated_cons, found_solutions, gamma_vals, sepa_rounds, all_f, all_a =\
        packing_algorithm(oracle, precision, maxiter, corr_freq, gamma,
                          initial_conss, solver, verif_model, silent=silent)

    suffix = " prec_%f corrfreq_%d initconss_%d solver_%s %s" %\
        (precision, corr_freq, initconss, solver, problemtype)
    if lbopt >= 0:
        suffix += " lbopt_%d" % lbopt

    # get results for standard LP loop
    LPinitconss = initconss
    if initconss == 0:
        # to compute a point in the LP cut loop, we need at least some constraints
        LPinitconss = 1

    problem = PROBLEM(instancefile, problemtype, solver, LPinitconss)
    lporacle = ORACLE(instancefile, problemtype, solver)
    dual_bounds_LP = cut_loop_LP(problem, lporacle, precision, maxiter, lbopt=lbopt)

    compare_primal_dual_LP(dual_bounds_LP, gamma_vals, separated_cons, sepa_rounds, all_f, all_a,
                           oracle.get_inner_radius(), problemtype, solver, instancefile,
                           initconss, suffix=suffix)

    print("best primal value found by packing algorithm:\t", OPT)

